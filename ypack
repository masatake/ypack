#!/bin/sh
#| -*- scheme -*- |#
:; exec gosh -- $0 "$@"
;; 
;; ypack --- es expression front end for pmaker, that was xpack
;; 
;;  Copyright (C) 2011 Masatake YAMATO
;; 
;;  This program is free software: you can redistribute it and/or modify
;;  it under the terms of the GNU General Public License as published by
;;  the Free Software Foundation; either version 3 of the License, or
;;  (at your option) any later version.
;; 
;;  This program is distributed in the hope that it will be useful,
;;  but WITHOUT ANY WARRANTY; without even the implied warranty of
;;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;  GNU General Public License for more details.
;; 
;;  You should have received a copy of the GNU General Public License
;;  along with this program.  If not, see <http://www.gnu.org/licenses/>.
;; 
;;  Author: Masatake YAMATO <yamato@redhat.com>
;;

;; INPUT: 
;;
;;  (ypack-name "...")
;;  (ypack-version "...")
;;  (ypack-require "...")...
;;  (ypack-entry FROM TO MODE ...)...
;;  (ypack-link  FROM TO)
;;  (ypack-dir   TO)
;;  (ypack-dummy TO)
;;
(use util.match)
(use file.util)
(use util.list)
(use gauche.parseopt)

(define-class <file-info> ()
  ((from :init-keyword :from)
   (to :init-keyword :to)
   (mode :init-keyword :mode)
   ))

(define-class <regular-info> (<file-info>)
  ())
(define-class <dir-info> (<file-info>)
  ())
(define-class <link-info> (<file-info>)
  ())
(define-class <dummy-info> (<file-info>)
  ((dummy-count :init-keyword :dummy-count)
   ))

(define-method prepare ((entry <regular-info>))
  (let1 dir-flag (if (file-is-directory? (ref entry 'from))
		     "-d" "")
    (print #`"install ,dir-flag -D --mode=,(ref entry 'mode) ,(ref entry 'from) build,(ref entry 'to)")))
(define-method prepare ((entry <dir-info>))
  (let1 dir (ref entry 'to)
    (print #`"mkdir -p build,|dir|")))
(define-method prepare ((entry <link-info>))
  (let ((dir (sys-dirname (ref entry 'from)))
	(link (sys-basename (ref entry 'from))))
    (print #`"mkdir -p build,|dir|")
    (print #`"ln -s ,(ref entry 'to) build,(ref entry 'from)")))
(define-method prepare ((entry <dummy-info>))
  (let1 to (ref entry 'to)
    (print #`"echo ,(ref entry 'dummy-count) > build,|to|")
    (print #`"chmod ,(ref entry 'mode) build,|to|")))

(define-method emit-file-list-entry ((entry <regular-info>))
  (print #`"$(pwd)/build,(ref entry 'to)"))
(define-method emit-file-list-entry ((entry <dir-info>))
  (print #`"$(pwd)/build,(ref entry 'to)"))
(define-method emit-file-list-entry ((entry <link-info>))
  (print #`"$(pwd)/build,(ref entry 'from)"))
(define-method emit-file-list-entry ((entry <dummy-info>))
  (print #`"$(pwd)/build,(ref entry 'to)"))


(define (gather)
  (let loop ((exp (read))
	     (name #f)
	     (version "0.0.0")
	     (entries (list))
	     (requires (list))
	     (dummy-count 0))
    (if (eof-object? exp)
	(values version name (reverse entries) requires)
	(case (car exp)
	  ('ypack-version (loop (read) name (cadr exp) entries requires dummy-count))
	  ('ypack-entry (match-let1 (from to . rest) (cdr exp)
				    (unless (file-exists? from)
				      (error "No such file: " from))
				    (let-keywords rest ((mode "u+w,a+rx"))
				      (loop (read)
					    name
					    version
					    (cons (make <regular-info>
						    :from from 
						    :to to
						    :mode mode)
						  entries)
					    requires
					    dummy-count))))
	  ('ypack-dir (match-let1 (to . rest) (cdr exp)
			(loop (read)
			      name
			      version
			      (cons (make <dir-info>
				      :from #f
				      :to to)
				    entries)
			      requires
			      dummy-count)
			))
	  ('ypack-link (match-let1 (from to . rest) (cdr exp)
			 (loop (read)
			       name
			       version
			       (cons (make <link-info>
				       :from from 
				       :to to)
				     entries)
			       requires
			       dummy-count)))
	  ('ypack-dummy (match-let1 (to . rest) (cdr exp)
			  (let-keywords rest ((mode "u+w,a+rx"))
			    (loop (read)
				  name
				  version
				  (cons (make <dummy-info>
					  :from #f
					  :to to
					  :mode mode
					  :dummy-count dummy-count)
					entries)
				  requires
				  (+ dummy-count 1)))))
	  ('ypack-name (loop (read)
			     (cadr exp)
			     version
			     entries
			     requires
			     dummy-count))
	  ('ypack-require (loop (read) 
				name
				version
				entries
				(cons (cadr exp) requires)
				dummy-count))
	  (else
	   (error "Unknown directive: " (car exp)))))))

(define (emit target version name entries requires)
  (define (emit-xpack-relations)
    (unless (null? requires)
      (let1 requires (apply string-append (intersperse "," requires))
	(print #`"	--requires ,|requires| \\"))))
  (define (emit-pmaker-relations)
    (unless (null? requires)
      (let1 requires (apply string-append (intersperse "," requires))
	(print #`"	--relations=requires:,|requires| \\"))))
  (unless name
    (error "No NAME given"))

  ;;
  (print "#!/bin/bash -x")
  (print "uv=${1:-0}")
  (newline)
  (print "rm -rf workdir build")
  (for-each prepare entries)

  (print #`",(symbol->string target) --verbose --name ,|name|	\\")
  (print #`"	--destdir=$(pwd)/build \\")
  (print "	--ignore-owner \\")
  (print #`"	--pversion=,|version|.${uv} \\")
  
  (case target
    ('xpack (emit-xpack-relations))
    ('pmaker (emit-pmaker-relations)))

  (print " - <<EOF")
  (for-each emit-file-list-entry entries)
  (print "EOF"))



(define (print-help status)
  (format #t "Usage: \n")
  (format #t "	~a --xpack  < _.ypk\n" *program-name*)
  (format #t "	~a --pmaker < _.ypk\n" *program-name*)
  (exit status))

(define (main args)
  (let-args (cdr args)
      ((help "h|help" => (pa$ print-help 0))
       (xpack "xpack" #f)
       (pmaker "pmaker" #t))
    (let1 target (if xpack 'xpack 'pmaker)
      (call-with-values gather (pa$ emit target)))))
